#!/usr/bin/env node

var getDeps = require('../src/get-deps')
	, sliceFile = require('read-slice')
	, resultify = require('resultify')
	, ghtag = resultify(require('github-latest'))
	, latestNPM = require('../src/latest-npm')
	, writeFile = require('writefile')
	, each = require('foreach/async')
	, eachfile = require('dir-each')
	, log = require('../src/logger')
	, program = require('commander')
	, apply = require('when/apply')
	, rmdir = require('rmdir/sync')
	, fs = require('resultify/fs')
	, Result = require('result')
	, map = require('map/async')
	, all = require('when-all')
	, install = require('..')
	, path = require('path')
	, format = log.format

// enable basic info

log.enable('info')

var home = process.env.HOME+'/.packin'
var links = home + '/links.json'
var cwd = process.cwd()

// load default config

var defaults = fs.existsSync(home+'/config.json')
	? require(home+'/config.json')
	: {}
'folder' in defaults || (defaults.folder = 'deps')
'meta' in defaults   || (defaults.meta = ['deps.json', 'component.json', 'package.json'])

program
	.version(require('../package').version)
	.option('-v, --verbose', 'turn up the logging')

program.on('verbose', function(){
	log.enable('debug')
})

program
	.command('add <key:url>')
	.description('add a package to this packages dependencies')
	.option('-d, --development', 'add as a development dependency')
	.on('--help', function(){
		print('  Examples:')
		print('')
		print('    # explicit')
		print('    $ packin add graph:http://github.com/jkroso/graph/tarball/master')
		print('')
		print('    # from github')
		print('    $ packin add jkroso/graph')
		print('')
	})
	.action(function(kv, opts){
		parseKeyValue(kv).read(function(kv){
			add(kv[0], kv[1], opts)
		})
	})

program
	.command('update [dep]')
	.description('update deps to their latest release')
	.action(function(dep){
		var json = getJSON()
		var pending = 0
		if (dep) {
			var deps = json.production && dep in json.production
				? json.production
				: json.development
			if (!(dep in deps)) throw new Error(dep + ' not installed')
			return apply(update(deps[dep], dep), function(url){
				deps[dep] = url
			}).read(function(){
				saveJSON(json)
				clearLine()
			})
		}
		if (json.production) json.production = map(json.production, update)
		if (json.development) json.development = map(json.development, update)
		all(json).read(function(json){
			saveJSON(json)
			clearLine()
		})
		function update(url, key){
			if (/github\.com\/([^\/]+)\/([^\/]+)\/tarball\/(.*)/.test(url)) {
				var user = RegExp.$1
				var repo = RegExp.$2
				var oldtag = RegExp.$3
				clearLine()
				writePending(++pending)
				return ghtag(user, repo).then(function(tag){
					var newurl = 'http://github.com/' + user + '/' + repo + '/tarball/' + tag
					clearLine()
					if (newurl != url) {
						log.info('updated', '%s/%s from %s to %s', user, repo, oldtag, tag)
					} else {
						log.info('ok', '%s/%s@%d', user, repo, tag)
					}
					return newurl
				}, function(e){
					clearLine()
					log.info('error', '%s. cant find latest tag for %s', e && e.message, repo)
					return url
				}).then(function(url){
					writePending(--pending)
					return url
				})
			}
			return url
		}
	})

function writePending(pending){
	process.stdout.write(blue('\r Â» ' + pending + ' pending'))
}
function clearLine(){
	process.stdout.write('\033[2K')
	process.stdout.write('\033[0G')
}

program
	.command('url <shorthand>')
	.description('expand shorthand to a full url')
	.action(function(short){
		parseKeyValue(short).read(function(url){
			log.info(url[0], url[1])
		})
	})

function parseKeyValue(kv){
	/([-.\w\/@]+)(?::([-.\w\/@]+))?/.exec(kv)
	if (RegExp.$2) {
		var key = RegExp.$1
		var value = RegExp.$2
	} else {
		var value = RegExp.$1
	}

	// github shorthand
	if (/^([-.\w]+)\/([-.\w]+)(?:@(.*))?$/.exec(value)) {
		var url = 'http://github.com/'+RegExp.$1+'/'+RegExp.$2+'/tarball/'
		var user = RegExp.$1
		var repo = RegExp.$2
		var tag = RegExp.$3
		if (!key) key = repo
		if (tag) return Result.wrap([key, url + tag])
		log.info('fetching', 'latest tag for %s/%s', user, repo)
		return ghtag(user, repo)
			.then(null, function(e){
				log.info('error', '%s. cant find latest tag for %s', e && e.message, repo)
				return 'master'
			})
			.then(function(tag){
				return [key, url + tag]
			})
	}

	// npm.org
	if (/^(.+)(?:@(.*))?$/.exec(value)) {
		var pkg = RegExp.$1
		var version = RegExp.$2 || '*'
		return latestNPM.url(pkg, version).then(function(url){
			return [pkg, url]
		})
	}
}

/**
 * get the deps.json file's data
 * 
 * @param {String} [file=./deps.json]
 * @return {Object}
 */

function getJSON(file){
	file || (file = cwd + '/deps.json')
	if (!fs.existsSync(file)) return {}
	return JSON.parse(fs.readFileSync(file, 'utf8'))
}

function saveJSON(json, file){
	file || (file = cwd + '/deps.json')
	fs.writeFileSync(file, JSON.stringify(json, null, 2))
}

/**
 * add an entry to the deps.json file
 * 
 * @param {String} key
 * @param {String} url
 * @param {Object} opts
 */

function add(key, url, opts){
	var file = cwd + '/deps.json'
	var json = getJSON(file)

	// --development
	if (opts.development) {
		var deps = json.development || (json.development = {})
	} else {
		var deps = json.production || (json.production = {})
	}

	log.info(key, url)
	deps[key] = url
	saveJSON(json, file)
}

program
	.command('ls')
	.description('display this packages dependencies')
	.option('-f, --folder <dir>', 'dependency directory', defaults.folder)
	.action(function(opts){
		var dev = getDeps(cwd, {
			files: defaults.meta,
			development: true
		})
		var pro = getDeps(cwd, {
			files: defaults.meta,
			production: true
		})
		apply(dev, pro, function(development, production){
			print('')
			show('production', production)
			show('development', development)
			
			function show(key, obj){
				var keys = Object.keys(obj)
				if (!keys.length) return
				print(format('  %s', blue(key)))
				keys.forEach(function(key){
					var url = obj[key]
					if (/github\.com\/([^\/]+)\/([^\/]+)\/tarball\/(.+)/.test(url)) {
						url = RegExp.$1 + '/' + RegExp.$2 + '@' + RegExp.$3
					}
					if (/registry\.npmjs\.org\/[^\/]+\/-\/(.*)-(.*)\.tgz/.test(url)) {
						url = RegExp.$1 + '@' + RegExp.$2
					}
					print(format('    %s %s', blue(key), url))
				})
				print('')
			}

			var links = fs.readdirSync(cwd+'/'+opts.folder).filter(function(file){
				if (file in production
				|| (file in development)) return false
				return fs
					.lstatSync(path.join(cwd, opts.folder, file))
					.isSymbolicLink()
			})

			if (links.length) { 
				print(blue('  links'))
				links.forEach(function(file){
					var pth = path.join(cwd, opts.folder, file)
					print(format('    %s %p -> %p', blue(file), pth, fs.realpathSync(pth)))
				})
				print('')
			}
		}).read()
	})

function blue(text){
	return '\033[36m' + text + '\033[m'
}

program
	.command('rm <key>')
	.description('remove a package from this packages dependencies')
	.option('-d, --development', 'add as a development dependency')
	.option('-f, --folder <dir>', 'dependency folder', defaults.folder)
	.action(function(name, opts){
		var pkg = cwd + '/deps.json'
		var json = require(pkg)
		var deps = opts.development
			? json.development
			: json.production
		if (deps && name in deps) {
			delete deps[name]
			var file = cwd + '/' + program.folder + '/' + name
			try { fs.unlinkSync(file) }
			catch (e) {}
			fs.writeFileSync(pkg, JSON.stringify(json, null, 2))
		}
	})

program
	.command('install')
	.description('install this packages dependencies')
	.option('-d, --development', 'install development dependencies')
	.option('-p, --production', 'install production dependencies')
	.option('-f, --folder <dir>', 'name of the directory for installed packages', defaults.folder)
	.option('-m, --meta <files>', 'list of meta files to read', list, defaults.meta)
	.option('-e, --executables', 'run chmod 755 on all executables')
	.option('-R, --no-retrace', 'don\'t step into existing dependencies')
	.on('--help', function () {
		print('  Examples:')
		print('')
		print('    # to emulate npm install')
		print('    $ packin install -em package.json')
		print('')
		print('    # to use components and npm packages')
		print('    $ packin install -m component.json,package.json')
		print('')
	})
	.action(function(options){
		touch(options.folder)
		
		var opts = {
			folder: options.folder,
			files: options.meta,
			log: Object.create(null),
			development: options.development,
			production: options.production,
			retrace: options.retrace
		}

		process.on('exit', cleanup)
		function cleanup(code, sig){
			console.log('  exited with code:%s', code)
			each(opts.log, function(dep){
				if (dep.isNew) rmdir(dep.location)
			})
		}

		install(cwd, opts).read(function(log){
			process.removeListener('exit', cleanup)
			if (!options.executables) return
			return each(log, function(dep){
				return chmodExecutables(dep.location)
			})
		})
	})

/**
 * make executables executable
 * 
 * @param {String} dir
 * @return {Promise} nil
 */

function chmodExecutables(dir){
	return eachfile(dir, function(file){
		return sliceFile(file, 0, 2).then(function(head){
			if (head == '#!') {
				log.info('executable', '%p', file)
				return fs.chmod(file, '755')
			}
		})
	})
}

/**
 * Touch `path` when present.
 *
 * @param {String} path
 * @api private
 */

function touch(path) {
	try { fs.utimesSync(path, new Date, new Date) }
	catch (err) {}
}

/**
 * register a local package so it can be linked to
 * 
 * @param {String} dir
 * @param {String} [name=basename]
 */

function register(dir, name){
	if (!name) name = path.basename(dir).toLowerCase()
	var locals = getLocals()
	if (name in locals && locals[name] != dir) {
		log.info('error', '%s currently assigned to %s', name, locals[name]) 
		return
	}
	locals[name] = dir
	saveLocals(locals)
	console.log()
	log.info('linked', '%s -> %s', name, dir)
	console.log()
}

/**
 * unregister a package from the linking index
 * 
 * @param {String} dir
 * @param {String} [name=basename]
 */

function unregister(dir, name){
	if (!name) name = path.basename(cwd).toLowerCase()
	var locals = getLocals()
	if (!(name in locals)) {
		log.info('warning', '%s is not registered', name)
		return
	}
	delete locals[name]
	saveLocals(locals)
	console.log()
	log.info('removed', '%s -> %s', name, dir)
	console.log()
}

/**
 * get the links index
 * @return {Object}
 */

function getLocals(){
	return fs.existsSync(links)
		? require(links)
		: {}
}

function mkdir(folder){
	try {
		fs.mkdirSync(folder)
	} catch (e) {
		if (e.code != 'EEXIST') throw e
	}
}

/**
 * save the links index
 * @param {Object} obj
 */

function saveLocals(obj){
	writeFile(links, JSON.stringify(obj, null, 2))
}

program
	.command('links')
	.description('list packages available for linking to')
	.action(function(){
		var locals = getLocals()
		var keys = Object.keys(locals)
		if (!keys.length) return print('none to show')
		print('')
		keys.forEach(function(key){
			var path = locals[key]
			path = path.replace(process.env.HOME, '~')
			log.info(key, path)
		})
		print('')
	})

program
	.command('link [name]')
	.description('link to a local package or register this one')
	.option('-f, --folder <dir>', 'name of the directory for installed packages', defaults.folder)
	.option('-n, --name <name>', 'set the name of this package when making it linkable')
	.on('--help', function(){
		print('  Examples:')
		print('')
		print('    # to make $PWD available as "my-module"')
		print('    $ packin link -n my-module')
		print('')
		print('    # to install "my-module"')
		print('    $ packin link my-module')
		print('')
	})
	.action(function(pkg, opts){
		// make linkable
		if (opts.name || !pkg) return register(cwd, opts.name)

		var locals = getLocals()
		if (!(pkg in locals)) {
			log.info('error', '%s is not registered', pkg)
			return
		}
		var deps = cwd + '/' + opts.folder
		mkdir(deps)
		var sym = deps+'/'+pkg
		try { fs.unlinkSync(sym) } catch (e) {}
		fs.symlinkSync(locals[pkg], sym)
		log.info('linked', '%p -> %p', sym, locals[pkg])
	})

program
	.command('unlink [name]')
	.description('unlink a local package or unregister this one')
	.option('-f, --folder <dir>', 'name of the directory for installed packages', defaults.folder)
	.option('-n, --name <name>', 'set the name of this package when making it linkable')
	.action(function(pkg, opts){
		// deregister this package
		if (opts.name || !pkg) return unregister(cwd, opts.name)
		
		fs.unlink(cwd + '/' + opts.folder + '/' + pkg, function(){
			// ignore errors
		})
	})

program.parse(process.argv)

if (!program.args.length) program.help()

function list (args) {
	return args.split(',')
}

function print(txt){
	process.stdout.write(txt+'\n')
}
