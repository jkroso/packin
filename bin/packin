#!/usr/bin/env node

var program = require('commander')
  , install = require('../src/install')
  , fs = require('fs')
  , ghtag = require('github-latest')
  , writeFile = require('writefile')
  , path = require('path')
  , mkdirp = require('mkdirp')
  , log = require('../src/logger')
  , Promise = require('laissez-faire/full')

// enable basic info

log.enable('info')

var home = process.env.HOME+'/.packin'
var links = home + '/links.json'
var cwd = process.cwd()

// load default config

var cfg = fs.existsSync(home+'/config.json')
	? require(home+'/config.json')
	: {}
if (!('target' in cfg)) cfg.target = 'dev'
if (!('meta' in cfg)) cfg.meta = ['deps.json', 'component.json', 'package.json']
if (!('dev' in cfg)) cfg.dev = true

program
	.version(require('../package').version)
	.option('-v, --verbose', 'turn up the logging')

program.on('verbose', function(){
	log.enable('debug')
})

program
	.command('add <key:url>')
	.description('add a package to this packages dependencies')
	.option('-d, --development', 'add as a development dependency')
	.on('--help', function(){
		print('  Examples:')
		print('')
		print('    # explicit')
		print('    $ packin add graph:http://github.com/jkroso/graph/tarball/master')
		print('')
		print('    # from github')
		print('    $ packin add jkroso/graph')
		print('')
	})
	.action(function(kv, opts){
		parseKeyValue(kv).then(function(kv){
			add(kv[0], kv[1], opts)
		})
	})

function parseKeyValue(kv){
	var p = new Promise;
	/([-.\w\/@]+)(?::([-.\w\/@]+))?/.exec(kv)
	if (RegExp.$2) {
		var key = RegExp.$1
		var value = RegExp.$2
	} else {
		var value = RegExp.$1
	}

	// github shorthand
	if (/^([-.\w]+)\/([-.\w]+)(?:@([-.\w]+|\d+\.\d+\.\d+))?$/.exec(value)) {
		value = 'http://github.com/'+RegExp.$1+'/'+RegExp.$2+'/tarball/'
		if (!key) key = RegExp.$2
		if (RegExp.$3) {
			value += RegExp.$3
			p.resolve([key,value])
		} else {
			ghtag(RegExp.$1, RegExp.$2, function(e, tag){
				if (e) log.info('error', 'unable to find the latest tag (%s)', e.message)
				value += (tag || 'master')
				p.resolve([key,value])
			})
			log.info('fetching', 'latest tag for %s/%s', RegExp.$1, RegExp.$2)
		}
	}

	return p
}

/**
 * getdeps object with production and development 
 * dependencies merged together
 * 
 * @param {String} [json='./deps.json']
 * @return {Object}
 */

function getAllDeps(json){
	json = getDeps(json)
	var deps = json.production || {}
	if (json.development) for (var k in json.development) {
		deps[k] = json.development[k]
	}
	return deps
}

/**
 * get the deps.json file's data
 * 
 * @param {String} [file=./deps.json]
 * @return {Object}
 */

function getDeps(file){
	file || (file = cwd + '/deps.json')
	if (!fs.existsSync(file)) return {}
	return require(file)
}

/**
 * add an entry to the deps.json file
 * 
 * @param {String} key
 * @param {String} url
 * @param {Object} opts
 */

function add(key, url, opts){
	var file = cwd + '/deps.json'
	var json = getDeps(file)

	// --development
	if (opts.development) {
		var deps = json.development || (json.development = {})
	} else {
		var deps = json.production || (json.production = {})
	}

	log.info(key, url)
	deps[key] = url
	fs.writeFileSync(file, JSON.stringify(json, null, 2))
}

program
	.command('ls')
	.description('display this packages dependencies')
	.option('-t, --target <dir>', 'dependency directory', cfg.target)
	.action(function(opts){
		var pkg = cwd + '/deps.json'
		var deps = require(pkg)
		console.log()
		show(deps.production)
		show(deps.development)
		function show(obj){
			if (!obj) return
			var keys = Object.keys(obj)
			if (!keys.length) return
			keys.forEach(function(key){
				log.info(key, obj[key])
			})
			console.log()
		}

		var locals = getLocals()

		var links = fs.readdirSync(cwd+'/'+opts.target).filter(function(file){
			if (deps.production && file in deps.production
			|| (deps.development && file in deps.development)
			|| !(file in locals)) return false
			var stat = fs.lstatSync(path.join(cwd, opts.target, file))
			return stat.isSymbolicLink()
		})

		if (links.length) { 
			links.forEach(function(file){
				var pth = path.join(cwd, opts.target, file)
				log.info(file, '%p -> %p', pth, fs.realpathSync(pth))
			})
			console.log()
		}
	})

program
	.command('rm <key>')
	.description('remove a package from this packages dependencies')
	.option('-d, --development', 'add as a development dependency')
	.option('-t, --target <dir>', 'dependency folder', cfg.target)
	.action(function(name, opts){
		var pkg = cwd + '/deps.json'
		var json = require(pkg)
		var deps = opts.development
			? json.development
			: json.production
		if (deps && name in deps) {
			delete deps[name]
			var file = cwd + '/' + program.target + '/' + name
			try { fs.unlinkSync(file) }
			catch (e) {}
			fs.writeFileSync(pkg, JSON.stringify(json, null, 2))
		}
	})


program
	.command('install [key:url]')
	.description('install this packages dependencies')
	.option('-p, --no-dev', 'ignore development dependencies', !cfg.dev)
	.option('-d, --development', 'install as a development dependency')
	.option('-t, --target <dir>', 'name of the directory for installed packages', cfg.target)
	.option('-m, --meta <files...>', 'list of meta files to read', list, cfg.meta)
	.on('--help', function () {
		print('  Examples:')
		print('')
		print('    # to emulate npm')
		print('    $ packin install -m package.json -t node_modules')
		print('')
		print('    # to use components with browserify')
		print('    $ packin install -m component.json,package.json -t node_modules')
		print('')
	})
	.action(function(kv, opts){
		var deps = getAllDeps()
		if (kv) {
			mkdirp.sync(opts.target)
			if (kv in deps) {
				return install.one(deps[kv], path.join(cwd, opts.target, kv), {
					folder: opts.target,
					priority: opts.meta
				}).throw()
			}
			parseKeyValue(kv).then(function(kv){
				var url = kv[1]
				var name = kv[0]
				add(name, url, opts)
				install.one(url, path.join(cwd, opts.target, name), {
					folder: opts.target,
					priority: opts.meta
				}).throw()
			})
		} else {
			install(cwd, {
				priority: opts.meta,
				dev: opts.dev,
				folder: opts.target
			}).throw()
		}
	})

/**
 * register a local package so it can be linked to
 * 
 * @param {String} dir
 * @param {String} [name=basename]
 */

function register(dir, name){
	if (!name) name = path.basename(dir).toLowerCase()
	var locals = getLocals()
	if (name in locals && locals[name] != dir) {
		log.info('error', '%s currently assigned to %s', name, locals[name]) 
		return
	}
	locals[name] = dir
	saveLocals(locals)
	console.log()
	log.info('linked', '%s -> %s', name, dir)
	console.log()
}

/**
 * unregister a package from the linking index
 * 
 * @param {String} dir
 * @param {String} [name=basename]
 */

function unregister(dir, name){
	if (!name) name = path.basename(cwd).toLowerCase()
	var locals = getLocals()
	if (!(name in locals)) {
		log.info('warning', '%s is not registered', name)
		return
	}
	delete locals[name]
	saveLocals(locals)
	console.log()
	log.info('removed', '%s -> %s', name, dir)
	console.log()
}

/**
 * get the links index
 * @return {Object}
 */

function getLocals(){
	return fs.existsSync(links)
		? require(links)
		: {}
}

/**
 * save the links index
 * @param {Object} obj
 */

function saveLocals(obj){
	writeFile(links, JSON.stringify(obj, null, 2))
}

program
	.command('links')
	.description('list packages available for linking to')
	// TODO
	// .option('-u, --used', 'list the linked packages this one is using')
	.action(function(){
		var locals = getLocals()
		var keys = Object.keys(locals)
		if (!keys.length) return print('none to show')
		print('')
		keys.forEach(function(key){
			var path = locals[key]
			path = path.replace(process.env.HOME, '~')
			log.info(key, path)
		})
		print('')
	})

program
	.command('link [name]')
	.description('link to a local package or set this one up for linking')
	.option('-t, --target <dir>', 'name of the directory for installed packages', cfg.target)
	.option('-n, --name <name>', 'set the name of this package when making it linkable')
	.action(function(pkg, opts){
		// make linkable
		if (opts.name || !pkg) return register(cwd, opts.name)

		var locals = getLocals()
		if (!(pkg in locals)) {
			log.info('error', '%s is not registered', pkg)
			return
		}
		var deps = cwd + '/' + opts.target
		mkdirp.sync(deps)
		var sym = deps+'/'+pkg
		try { fs.unlinkSync(sym) } catch (e) {}
		fs.symlinkSync(locals[pkg], sym)
		log.info('linked', '%p -> %p', sym, locals[pkg])
	})

program
	.command('unlink [name]')
	.description('unlink a local package or unregister this one from the index')
	.option('-t, --target <dir>', 'name of the directory for installed packages', cfg.target)
	.option('-n, --name <name>', 'set the name of this package when making it linkable')
	.action(function(pkg, opts){
		// deregister this package
		if (opts.name || !pkg) return unregister(cwd, opts.name)
		
		fs.unlink(cwd + '/' + opts.target + '/' + pkg, function(){
			// ignore errors
		})
	})

program.parse(process.argv)

if (!program.args.length) program.help()

function list (args) {
	return args.split(',')
}

function print(txt){
	process.stdout.write(txt+'\n')
}
